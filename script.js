const projectsData = {
  "Gonzalo Hernandez": {
"defaultName": "Gonzalo Hernandez",
"defaultImage": "projects/gonzalo/gonzalo.png",
"expectedTechnologies": [
"Adobe", "UI", "UX", "Figma", "Arduino", "HTML", "CSS", "Javascript",
"MongoDB", "ChatGPT", "Processing", "MakeyMakey", "8Wall", "Midjourney",
"SparkAR", "Unity3D", "Meta", "OpenSea", "Three.js", "Supabase", "Python"
],
"techContent": {
"Adobe": {
 "text": "Diseño Gráfico", 
 "image": "projects/gonzalo/adobe.png"
},
"UI": {
 "text": "Diseño de Interfaces",
 "image": "projects/gonzalo/ui.png"
},
"UX": {
 "text": "Diseño de Experiencia",
 "image": "projects/gonzalo/ux.png"
},
"Figma": {
 "text": "Prototipos",
 "image": "projects/gonzalo/figma.png"
},
"Arduino": {
 "text": "Electrónica",
 "image": "projects/gonzalo/arduino.png"
},
"HTML": {
 "text": "Webs",
 "image": "projects/gonzalo/html.png"
},
"CSS": {
 "text": "Estilado",
 "image": "projects/gonzalo/css.png"
},
"Javascript": {
 "text": "Interactividad",
 "image": "projects/gonzalo/javascript.png"
},
"MongoDB": {
 "text": "Control de datos",
 "image": "projects/gonzalo/mongodb.png"
},
"ChatGPT": {
 "text": "Inteligencia Artificial",
 "image": "projects/gonzalo/chatgpt.png"
},
"Processing": {
 "text": "Arte Digital",
 "image": "projects/gonzalo/processing.png"
},
"MakeyMakey": {
 "text": "Interfaces alternativas",
 "image": "projects/gonzalo/makeymakey.png"
},
"8Wall": {
 "text": "Realidad Aumentada Web",
 "image": "projects/gonzalo/8wall.png"
},
"Midjourney": {
 "text": "Inteligencia Artificial Generativa",
 "image": "projects/gonzalo/midjourney.png"
},
"SparkAR": {
 "text": "Realidad Aumentada Redes",
 "image": "projects/gonzalo/sparkar.png"
},
"Unity3D": {
 "text": "Programación 3D",
 "image": "projects/gonzalo/unity3d.png"
},
"Meta": {
 "text": "Realidad Virtual",
 "image": "projects/gonzalo/meta.png"
},
"OpenSea": {
 "text": "NFT",
 "image": "projects/gonzalo/opensea.png"
},
"Three.js": {
 "text": "Arte Generativo",
 "image": "projects/gonzalo/threejs.png"
},
"Supabase": {
 "text": "Proyectos Complejos",
 "image": "projects/gonzalo/supabase.png"
},
"Python": {
 "text": "Programación de soluciones",
 "image": "projects/gonzalo/python.png"
}
},
"nombreProyecto": "Gonzalo Hernandez",
"descripcion": "",
"contexto": "",
"objetivo": "",
"innovacion": "",
"desarrollo1": "",
"desarrolloImagen1": "",
"desarrollo2": "",
"desarrolloImagen2": "",
"resultado": "",
"resultadoImagen": ""
},"SPILLS": {
"defaultName": "Spills",
"defaultImage": "projects/spills/spills_01.png",
"portadaImage": "projects/spills/spills_portada.png",
"expectedTechnologies": ["Adobe", "Figma"],
"techContent": {
"Adobe": { "text": "Diseño con Adobe Suite", "image": "projects/spills/spills_02.png" },
"Figma": { "text": "Prototipado y diseño en Figma", "image": "projects/spills/spills_03.png" }
},
"nombreProyecto": "Spills",
"descripcion": "Identidad corporativa para una productora de experiencias interactivas que fusiona innovación y tecnología.",
"contexto": "Fundada para trabajar con agencias de comunicación y materializar las propuestas creativas de las marcas, Spills ha desarrollado experiencias en Uruguay, Paraguay, Argentina y Chile desde 2022.",
"objetivo": "Establecer una imagen de marca distintiva y vanguardista que refleje la capacidad innovadora de la productora para transformar ideas en experiencias interactivas.",
"innovacion": "La identidad de Spills destaca por su enfoque disruptivo, combinando tecnología y creatividad para posicionar a la marca como referente en innovación en el sector de experiencias interactivas.",
"desarrollo1": "Conceptualización y estrategia: Se definió el concepto creativo y la estrategia visual, alineando la identidad con la visión innovadora de la productora.",
"desarrolloImagen1": "projects/spills/spills_02.png",
"desarrollo2": "Diseño y prototipado: Utilizando Adobe Suite y Figma, se diseñó y prototipó la identidad corporativa, asegurando coherencia y modernidad en cada elemento.",
"desarrolloImagen2": "projects/spills/spills_03.png",
"resultado": "Una identidad corporativa sólida que ha permitido a la productora destacar en el mercado y colaborar exitosamente con agencias de comunicación a nivel regional.",
"resultadoImagen": "projects/spills/spills_final.png"
},  "FRUITMIX": {
"defaultName": "Fruitmix",
"defaultImage": "projects/fruitmix/fruitmix_01.png",
"portadaImage": "projects/fruitmix/fruitmix_portada.png",
"expectedTechnologies": ["Processing", "Makey"],
"techContent": {
"Processing": { "text": "Desarrollo interactivo con Processing", "image": "projects/fruitmix/fruitmix_02.png" },
"Makey": { "text": "Interfaz física con MakeyMakey", "image": "projects/fruitmix/fruitmix_03.png" }
},
"nombreProyecto": "Fruitmix",
"descripcion": "Experiencia interactiva donde frutas activan samples musicales para crear composiciones en tiempo real.",
"contexto": "Proyecto desarrollado para la materia Arte Digital 1, explorando la interacción entre objetos cotidianos y la creación musical a través del tacto.",
"objetivo": "Permitir a los usuarios interactuar con frutas para activar diferentes samples de ritmos, melodías y armonías, creando música en vivo.",
"innovacion": "Fruitmix integra interfaces físicas inusuales con tecnología digital, transformando la manera de interactuar con la música y la sensibilidad a través del tacto.",
"desarrollo1": "Implementación de la interfaz: Se configuró un entorno en Processing para generar música en respuesta a la interacción física, utilizando MakeyMakey para detectar el tacto sobre las frutas.",
"desarrolloImagen1": "projects/fruitmix/fruitmix_02.png",
"desarrollo2": "Asignación de samples: Cada fruta fue programada para controlar un sample de ritmos, melodías y armonías loopeadas, permitiendo la composición musical en tiempo real.",
"desarrolloImagen2": "projects/fruitmix/fruitmix_03.png",
"resultado": "Fruitmix demostró el potencial de las interfaces alternativas en el arte digital, ofreciendo una experiencia musical y sensitiva innovadora y participativa.",
"resultadoImagen": "projects/fruitmix/fruitmix_final.png"
},"SHOPPYFY": {
"defaultName": "Shoppyfy",
"defaultImage": "projects/shoppyfy/shoppyfy_01.png",
"portadaImage": "projects/shoppyfy/shoppyfy_portada.png",
"expectedTechnologies": ["Figma", "Adobe", "UX", "UI"],
"techContent": {
"Figma": { "text": "Prototipado en Figma", "image": "projects/shoppyfy/shoppyfy_02.png" },
"Adobe": { "text": "Diseño con Adobe", "image": "projects/shoppyfy/shoppyfy_04.png" },
"UX": { "text": "Optimización de la experiencia de usuario", "image": "projects/shoppyfy/shoppyfy_03.png" },
"UI": { "text": "Interfaz de usuario intuitiva", "image": "projects/shoppyfy/shoppyfy_02.png" }
},
"nombreProyecto": "Shoppyfy",
"descripcion": "App móvil prototipada para facilitar la gestión de finanzas compartidas con un enfoque en UX/UI.",
"contexto": "Desarrollada para la materia Diseño de Interfaces, Shoppyfy se creó para abordar las necesidades de usuarios que comparten gastos, integrando principios de diseño centrados en el usuario.",
"objetivo": "Facilitar la administración de finanzas compartidas, permitiendo a los usuarios gestionar gastos y contribuciones de manera eficiente y transparente.",
"innovacion": "Shoppyfy se destaca por su enfoque en la simplicidad y usabilidad, combinando herramientas de prototipado avanzado y diseño centrado en el usuario para transformar la experiencia financiera en grupo.",
"desarrollo1": "Prototipado: Se diseñó la app en Figma, creando wireframes y prototipos interactivos que reflejaban flujos de usuario intuitivos y eficientes.",
"desarrolloImagen1": "projects/shoppyfy/shoppyfy_02.png",
"desarrollo2": "Diseño visual y experiencia: Se utilizó Adobe y metodologías UX/UI para refinar la interfaz, asegurando una experiencia visual atractiva y funcional.",
"desarrolloImagen2": "projects/shoppyfy/shoppyfy_03.png",
"resultado": "Shoppyfy logró un prototipo funcional y estéticamente atractivo que simplifica la gestión de finanzas compartidas, destacándose como una propuesta innovadora en diseño de interfaces.",
"resultadoImagen": "projects/shoppyfy/shoppyfy_final.png"
},"MISSINGTRACK": {
"defaultName": "missing track",
"defaultImage": "projects/missingtrack/missingtrack_01.png",
"portadaImage": "projects/missingtrack/missingtrack_portada.png",
"expectedTechnologies": ["Zeballos", "BK", "SparkAR"],
"techContent": {
"Zeballos": { "text": "Difusión de evento con Zeballos", "image": "projects/missingtrack/missingtrack_02.png" },
"BK": { "text": "Integración de marca BK", "image": "projects/missingtrack/missingtrack_04.png" },
"SparkAR": { "text": "Códigos interactivos con SparkAR", "image": "projects/missingtrack/missingtrack_03.png" }
},
"nombreProyecto": "missing track",
"descripcion": "Campaña interactiva que convierte afiches en códigos para acceder a premios en el show de Zeballos.",
"contexto": "El 21 de Octubre, Zeballos realizará un gran show en el Teatro de Verano para más de 4000 personas. Para la difusión, se colocaron afiches por toda la ciudad.",
"objetivo": "Incentivar a los fans a salir a la calle, escanear los afiches interactivos y ganar premios como merch oficial, productos y una canción inédita, fomentando la participación a través de redes sociales al etiquetar a BK.",
"innovacion": "La campaña fusiona lo físico y digital al convertir afiches en códigos interactivos, creando una experiencia de búsqueda y participación que se extiende a las redes sociales.",
"desarrollo1": "Transformación digital de afiches: Se integraron códigos interactivos en los afiches utilizando SparkAR, invitando al público a descubrir sorpresas y premios al escanearlos.",
"desarrolloImagen1": "projects/missingtrack/missingtrack_02.png",
"desarrollo2": "Activación en redes sociales: Los participantes debieron compartir videos en sus stories y etiquetar a BK, generando una dinámica viral en torno al evento.",
"desarrolloImagen2": "projects/missingtrack/missingtrack_04.png",
"resultado": "La campaña logró una alta interacción y participación, ampliando la visibilidad del evento y conectando de forma innovadora al público con el show de Zeballos.",
"resultadoImagen": "projects/missingtrack/missingtrack_final.png"
}
,"DREAMDRIVE": {
"defaultName": "dreamdrive",
"defaultImage": "projects/dreamdrive/dreamdrive_01.png",
"portadaImage": "projects/dreamdrive/dreamdrive_portada.png",
"expectedTechnologies": ["OpenSea", "Arduino", "Electron", "Threejs", "Ender", "BMW"],
"techContent": {
"OpenSea": { "text": "Gestión y creación de NFT en OpenSea", "image": "projects/dreamdrive/dreamdrive_02.png" },
"Arduino": { "text": "Sensado de datos con Arduino", "image": "projects/dreamdrive/dreamdrive_07.png" },
"Electron": { "text": "Aplicación desktop con Electron", "image": "projects/dreamdrive/dreamdrive_03.png" },
"Threejs": { "text": "Visualización 3D con Threejs", "image": "projects/dreamdrive/dreamdrive_08.png" },
"Ender": { "text": "Prototipado e impresión con Creality", "image": "projects/dreamdrive/dreamdrive_04.png" },
"BMW": { "text": "Experiencia test drive para BMW", "image": "projects/dreamdrive/dreamdrive_06.png" }
},
"nombreProyecto": "dreamdrive",
"descripcion": "Activación para BMW Paraguay que transforma las sensaciones de un test drive en una obra de arte generativo convertida en NFT.",
"contexto": "Proyecto desarrollado para BMW Paraguay, a cargo de la empresa Perfecta, representante de BMW en Paraguay, con el fin de innovar en activaciones de experiencias test drive.",
"objetivo": "Recopilar las sensaciones del test drive mediante métodos de sensado y transformarlas en una obra de arte digital única, que se materializa como un NFT para enriquecer la experiencia del cliente.",
"innovacion": "Integración de tecnología de sensado, arte generativo y blockchain, fusionando la experiencia física del test drive con una transformación digital artística y coleccionable.",
"desarrollo1": "Recopilación y procesamiento de datos: Durante el test drive, se utilizan dispositivos de sensado (guantes) para capturar las sensaciones del usuario, cuyos datos son almacenados para ser transformados en una obra de arte generativo.",
"desarrolloImagen1": "projects/dreamdrive/dreamdrive_05.png",
"desarrollo2": "Generación y exportación de la obra: Los datos recopilados se procesan para crear una imagen única mediante técnicas de arte generativo, que luego se exporta y convierte en un NFT a través de OpenSea.",
"desarrolloImagen2": "projects/dreamdrive/dreamdrive_08.png",
"resultado": "Una experiencia innovadora que fusiona la vivencia del test drive con la tecnología digital, generando una pieza de arte única y coleccionable en forma de NFT, fortaleciendo la conexión emocional con la marca BMW.",
"resultadoImagen": "projects/dreamdrive/dreamdrive_final.png"
},"FEEL4REAL": {
"defaultName": "feel4real",
"defaultImage": "projects/feel4real/feel4real_01.png",
"portadaImage": "projects/feel4real/feel4real_portada.png",
"expectedTechnologies": ["Figma", "SparkAR", "Unity", "Meta", "Adobe", "CP"],
"techContent": {
"Figma": { "text": "Prototipado y diseño en Figma", "image": "projects/feel4real/feel4real_05.png" },
"SparkAR": { "text": "Filtro de realidad aumentada con SparkAR", "image": "projects/feel4real/feel4real_07.png" },
"Unity": { "text": "Desarrollo de experiencia VR en Unity3D", "image": "projects/feel4real/feel4real_06.png" },
"Meta": { "text": "Integración con dispositivos Meta", "image": "projects/feel4real/feel4real_04.png" },
"Adobe": { "text": "Creación de contenidos con Adobe", "image": "projects/feel4real/feel4real_03.png" },
"CP": { "text": "Evento internacional Campus Party", "image": "projects/feel4real/feel4real_02.png" }
},
"nombreProyecto": "feel4real",
"descripcion": "Campaña 360 para Campus Party que une cartelería interactiva con experiencias AR y VR.",
"contexto": "Desarrollado en el marco de la materia Comunicación Visual 2, el proyecto se planteó para generar contenido previo, durante y posterior al evento Campus Party mediante una estrategia multimedia innovadora.",
"objetivo": "Conectar la publicidad en vía pública con experiencias digitales, permitiendo a los usuarios acceder a filtros de AR y a una experiencia VR que recrea el Campus Party a través de lentes Meta.",
"innovacion": "La campaña integra cartelería interactiva con realidad aumentada y virtual, ofreciendo un roadmap que guía a los usuarios desde el espacio público hasta una vivencia digital completa del evento.",
"desarrollo1": "Implementación de cartelería y AR: Se desarrolló una estrategia de cartelería en vía pública que redirige a una web con un filtro de realidad aumentada, permitiendo visualizar la ubicación de otros afiches interactivos.",
"desarrolloImagen1": "projects/feel4real/feel4real_07.png",
"desarrollo2": "Desarrollo de experiencia VR: Se implementó un roadmap interactivo que, tras la interacción con todos los afiches, revela el lugar y hora de una experiencia VR, permitiendo vivir el Campus Party mediante lentes Meta.",
"desarrolloImagen2": "projects/feel4real/feel4real_03.png",
"resultado": "La campaña generó alta interacción y conectó el entorno físico con experiencias digitales, ofreciendo una propuesta innovadora y completa para vivir Campus Party de forma inmersiva.",
"resultadoImagen": "projects/feel4real/feel4real_final.png"
}
,"PODRIA": {
"defaultName": "Podr-ía ser familiar tuyo",
"defaultImage": "projects/podria/podria_01.png",
"portadaImage": "projects/podria/podria_portada.png",
"expectedTechnologies": ["Midjourney", "Adobe", "8Wall", "familiares"],
"techContent": {
"Midjourney": { "text": "Imágenes generadas con IA en Midjourney", "image": "projects/podria/podria_02.png" },
"Adobe": { "text": "Diseño y edición con Adobe", "image": "projects/podria/podria_04.png" },
"8Wall": { "text": "Experiencia de realidad aumentada con 8Wall", "image": "projects/podria/podria_03.png" },
"familiares": { "text": "Mensaje de empatía: 'Podría ser familiar tuyo'", "image": "projects/podria/podria_04.png" }
},
"nombreProyecto": "Podr-ía ser familiar tuyo",
"descripcion": "Afiche de concientización que utiliza un rostro generado por IA y realidad aumentada para sensibilizar sobre desaparecidos.",
"contexto": "Inspirado en la marcha del silencio en Uruguay, el afiche fue diseñado para sensibilizar a quienes observan pancartas de desaparecidos sin empatizar, invitándolos a reflexionar sobre la cercanía del dolor ajeno.",
"objetivo": "Concientizar a la población sobre la importancia de empatizar con los desaparecidos, incluso si no son familiares directos, y provocar una reflexión sobre la indiferencia social.",
"innovacion": "Integración de un rostro ficticio generado con IA y un código QR que activa una experiencia en realidad aumentada, permitiendo ver sobre el afiche rostros de verdaderos desaparecidos.",
"desarrollo1": "Diseño conceptual y gráfico: Se desarrolló el afiche utilizando Adobe y Midjourney para crear un rostro impactante que simboliza la ausencia y el dolor, enmarcado en la campaña de concientización.",
"desarrolloImagen1": "projects/podria/podria_02.png",
"desarrollo2": "Integración de realidad aumentada: Se implementó un código QR en el afiche que, al ser escaneado, levanta una experiencia AR mediante 8Wall, mostrando imágenes de verdaderos desaparecidos.",
"desarrolloImagen2": "projects/podria/podria_03.png",
"resultado": "El afiche y la experiencia AR generaron un fuerte impacto emocional, logrando sensibilizar al público y destacar la campaña como una propuesta innovadora en diseño corporativo.",
"resultadoImagen": "projects/podria/podria_final.png"
},
"BURGER_DAY": {
"defaultName": "Burger Day",
"defaultImage": "projects/burgerday/burgerday_01.png",
"portadaImage": "projects/burgerday/burgerday_portada.png",
"expectedTechnologies": ["Figma", "HTML", "CSS", "Javascript", "8Wall", "BK"],
"techContent": {
"Figma": { "text": "Diseño y prototipado en Figma", "image": "projects/burgerday/burgerday_06.png" },
"HTML": { "text": "Estructura web con HTML", "image": "projects/burgerday/burgerday_03.png" },
"CSS": { "text": "Estilos y diseño con CSS", "image": "projects/burgerday/burgerday_04.png" },
"Javascript": { "text": "Interactividad con JavaScript", "image": "projects/burgerday/burgerday_02.png" },
"8Wall": { "text": "Implementación de realidad aumentada con 8Wall", "image": "projects/burgerday/burgerday_05.png" },
"BK": { "text": "Integración temática de Burger King", "image": "projects/burgerday/burgerday_06.png" }
},
"nombreProyecto": "Burger Day",
"descripcion": "Web responsive para una promoción de Burger King que integra registro y realidad aumentada para ganar una Whopper gratis.",
"contexto": "Desarrollado como parte de un proyecto de Diseño Web, la campaña utiliza la temática de Burger King para conmemorar el día de la hamburguesa, fusionando tecnología digital y experiencia interactiva.",
"objetivo": "Crear una web responsive que permita a los usuarios registrarse desde desktop y mobile, y acceder a un filtro de realidad aumentada para colocar el monumento a la hamburguesa en un lugar icónico y ganar una Whopper gratis.",
"innovacion": "La integración de un filtro de realidad aumentada en una campaña promocional transforma una experiencia tradicional en una vivencia interactiva y digitalmente innovadora.",
"desarrollo1": "Diseño y prototipado: Se desarrolló el diseño en Figma y se creó una interfaz web responsive, optimizada para dispositivos móviles y desktop, facilitando el registro de los usuarios.",
"desarrolloImagen1": "projects/burgerday/burgerday_03.png",
"desarrollo2": "Implementación de realidad aumentada: Se integró un filtro de AR mediante 8Wall, permitiendo a los usuarios ubicar el monumento a la hamburguesa en escenarios reales para participar en la promoción.",
"desarrolloImagen2": "projects/burgerday/burgerday_04.png",
"resultado": "Burger Day transformó la tradicional promoción en una experiencia digital interactiva, generando gran participación y visibilidad en redes y medios digitales para Burger King.",
"resultadoImagen": "projects/burgerday/burgerday_final.png"
},
"TRIV-IA": {
"defaultName": "TRIV-IA",
"defaultImage": "projects/trivia/trivia_01.png",
"portadaImage": "projects/trivia/trivia_portada.png",
"expectedTechnologies": ["HTML", "CSS", "JavaScript", "MongoDB", "ChatGPT", "Figma"],
"techContent": {    
"HTML": { "text": "Estructura web con HTML", "image": "projects/trivia/trivia_03.png" },
"CSS": { "text": "Estilos y diseño con CSS", "image": "projects/trivia/trivia_02.png" },
"JavaScript": { "text": "Interactividad con JavaScript", "image": "projects/trivia/trivia_04.png" },
"MongoDB": { "text": "Gestión de datos con MongoDB", "image": "projects/trivia/trivia_05.png" },
"ChatGPT": { "text": "Generación dinámica de preguntas con ChatGPT", "image": "projects/trivia/trivia_06.png" },
"Figma": { "text": "Diseño de interfaz en Figma", "image": "projects/trivia/trivia_01.png" }
},
"nombreProyecto": "TRIV-IA",
"descripcion": "Plataforma web de trivia multijugador que genera preguntas en vivo mediante inteligencia artificial.",
"contexto": "Desarrollado en el marco del curso de Programación 2, TRIV-IA integra una experiencia de juego interactivo donde jugadores participan desde sus celulares, accediendo a una sala de espera y compitiendo en tiempo real en una pantalla central.",
"objetivo": "Crear una experiencia de trivia innovadora que permita a los jugadores competir en tiempo real, utilizando dispositivos móviles para interactuar y una interfaz web que, mediante IA, genere preguntas dinámicas que premian la rapidez y precisión en las respuestas.",
"innovacion": "La incorporación de la API de ChatGPT para la generación en vivo de preguntas y la integración fluida entre dispositivos móviles y la pantalla principal transforman la experiencia clásica de trivia en un entorno interactivo y multijugador único.",
"desarrollo1": "Implementación de la arquitectura de juego: Se desarrolló una plataforma web donde, al escanear un código desde el celular, los jugadores ingresan su nombre y se unen a la sala de espera, preparándose para competir en una sesión organizada por el host.",
"desarrolloImagen1": "projects/trivia/trivia_04.png",
"desarrollo2": "Integración de IA y sistema de puntuación: Se conectó la API de ChatGPT para generar preguntas en tiempo real, y se implementó un sistema de puntaje que evalúa tanto la corrección como la velocidad de respuesta, culminando en la presentación del ganador y el podio.",
"desarrolloImagen2": "projects/trivia/trivia_03.png",
"resultado": "Plataforma funcional y atractiva que permitió la participación simultánea de múltiples jugadores, demostrando el potencial de la IA en entornos de juego en tiempo real y consolidando habilidades prácticas en el desarrollo web.",
"resultadoImagen": "projects/trivia/trivia_final.png"
},
"PIXO": {
"defaultName": "PIXO",
"defaultImage": "projects/webPixo/pixo_01.png",
"portadaImage": "projects/webPixo/pixo_portada.png",
"expectedTechnologies": ["Arduino", "Figma", "Adobe", "EdTech"],
"techContent": {
"Arduino": { "text": "Programación en Arduino", "image": "projects/webPixo/pixo_03.png" },
"Figma": { "text": "Prototipado en Figma", "image": "projects/webPixo/pixo_02.png" },
"Adobe": { "text": "Diseño con Adobe Suite", "image": "projects/webPixo/pixo_04.png" },
"EdTech": { "text": "Metodologías EdTech", "image": "projects/webPixo/pixo_05.png" }
},
"nombreProyecto": "PIXO",
"descripcion": "Kit educativo que enseña programación y electrónica a través de la creación de una consola de videojuegos.",
"contexto": "Surgido del CIE de la Universidad ORT, PIXO combina tecnología y educación en un enfoque práctico y lúdico, acercando la programación y la electrónica a través de la construcción de una consola.",
"objetivo": "Brindar una herramienta innovadora que facilite el aprendizaje práctico y gradual en programación y electrónica, incentivando la creatividad y el interés por la tecnología.",
"innovacion": "PIXO transforma la educación tecnológica al integrar el aprendizaje práctico con la creación de videojuegos clásicos en una consola construida por los propios usuarios.",
"desarrollo1": "Planificación de cursos: Se diseñaron tres cursos graduales y tres guías de creación de videojuegos, orientados a introducir a nuevos usuarios en la programación en Arduino C++.",
"desarrolloImagen1": "projects/webPixo/pixo_04.png",
"desarrollo2": "Prototipado y diseño: Se realizó el prototipo de la web en Figma y Adobe Suite, aplicando metodologías EdTech y UI, y se contribuyó en el diseño de placas electrónicas para el kit.",
"desarrolloImagen2": "projects/webPixo/pixo_02.png",
"resultado": "Obtención de financiamiento de la ANII, consolidando PIXO como una herramienta educativa única en Uruguay y despertando un creciente interés en la programación y la electrónica.",
"resultadoImagen": "projects/webPixo/pixo_final.png"
}


};


// ===============================
// CONSTANTES CONFIGURABLES
// ===============================
const UNION_RANGE = 400;    // Rango para activar la conexión
const MARKER_HEIGHT = 8;    // Distancia desde el borde hasta la punta del triángulo
const MARKER_BASE = 12;     // Longitud de la base del triángulo
const HOVER_FACTOR = 0.3;   // Factor para desplazar los iconos al hacer hover sobre la tarjeta

const formInputsOrder = ["in_name", "in_email", "in_subject", "in_message"];
const validStates = [false, false, false, false]; // which inputs are valid
// Basic validation is unchanged (non-empty, email includes '@').

// Utility to get bounding rect relative to a container
function getRelativeRect(element, container) {
const rect = element.getBoundingClientRect();
const contRect = container.getBoundingClientRect();
return {
left: rect.left - contRect.left,
top: rect.top - contRect.top,
width: rect.width,
height: rect.height
};
}

function getElementCenter(element, container) {
const r = getRelativeRect(element, container);
return { x: r.left + r.width/2, y: r.top + r.height/2 };
}

// For border intersection: we find where a line from center -> target intersects the border
function getBorderIntersection(element, targetPoint, container) {
const r = getRelativeRect(element, container);
const center = { x: r.left + r.width/2, y: r.top + r.height/2 };
const dx = targetPoint.x - center.x;
const dy = targetPoint.y - center.y;
if (dx === 0 && dy === 0) return center; // same point => no intersection
const absDx = Math.abs(dx);
const absDy = Math.abs(dy);
const halfWidth = r.width/2;
const halfHeight = r.height/2;
let scale = (absDx/halfWidth > absDy/halfHeight)
? halfWidth/absDx
: halfHeight/absDy;
return {
x: center.x + dx*scale,
y: center.y + dy*scale
};
}

function getElementBorderSide(element, point, container) {
const r = getRelativeRect(element, container);
const dLeft   = Math.abs(point.x - r.left);
const dRight  = Math.abs(point.x - (r.left + r.width));
const dTop    = Math.abs(point.y - r.top);
const dBottom = Math.abs(point.y - (r.top + r.height));
const min = Math.min(dLeft, dRight, dTop, dBottom);
if      (min === dLeft)   return "left";
else if (min === dRight)  return "right";
else if (min === dTop)    return "top";
else                      return "bottom";
}

// Vector helpers
function normalize(v) {
const len = Math.hypot(v.x, v.y);
return len ? { x: v.x/len, y: v.y/len } : { x: 0, y: 0 };
}
function add(v, w) { return { x: v.x + w.x, y: v.y + w.y }; }
function multiply(v, s) { return { x: v.x*s, y: v.y*s }; }

/* =======================
CREATE POLYGON CONNECTION
border-to-border with arrow tips
======================= */
function createPolygonConnection(elemA, elemB, group, container) {
// We'll define arrow sizes
const MARKER_HEIGHT = 8;
const MARKER_BASE   = 12;

// Make an SVG <g> to hold line + polygons
const connGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
group.appendChild(connGroup);

// The main line
const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
line.setAttribute("stroke", "black");
line.setAttribute("stroke-width", "3");
connGroup.appendChild(line);

// Polygons for arrowheads near each border
const polyA = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
polyA.setAttribute("fill", "black");
connGroup.appendChild(polyA);

const polyB = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
polyB.setAttribute("fill", "black");
connGroup.appendChild(polyB);

// In next frame, measure & place
requestAnimationFrame(() => {
const Acenter = getElementCenter(elemA, container);
const Bcenter = getElementCenter(elemB, container);

// Intersection from A border => B center
const ABasePoint = getBorderIntersection(elemA, Bcenter, container);
// Intersection from B border => A center
const BBasePoint = getBorderIntersection(elemB, Acenter, container);

// Then define arrow tips
const dA = normalize({ x: Bcenter.x - Acenter.x, y: Bcenter.y - Acenter.y });
const dB = normalize({ x: Acenter.x - Bcenter.x, y: Acenter.y - Bcenter.y });

const ATip = add(ABasePoint, multiply(dA, MARKER_HEIGHT));
const BTip = add(BBasePoint, multiply(dB, MARKER_HEIGHT));

// For polygons, we need the side direction (left or right)
const sideA = getElementBorderSide(elemA, ABasePoint, container);
const baseDirA = (sideA === "left" || sideA === "right") ? { x: 0, y: 1 } : { x: 1, y: 0 };

const ABaseLeft = add(ABasePoint, multiply(baseDirA, -MARKER_BASE/2));
const ABaseRight= add(ABasePoint, multiply(baseDirA,  MARKER_BASE/2));

const sideB = getElementBorderSide(elemB, BBasePoint, container);
const baseDirB = (sideB === "left" || sideB === "right") ? { x: 0, y: 1 } : { x: 1, y: 0 };

const BBaseLeft = add(BBasePoint, multiply(baseDirB, -MARKER_BASE/2));
const BBaseRight= add(BBasePoint, multiply(baseDirB,  MARKER_BASE/2));

// Line coords
line.setAttribute("x1", ATip.x);
line.setAttribute("y1", ATip.y);
line.setAttribute("x2", BTip.x);
line.setAttribute("y2", BTip.y);

// Polygons
polyA.setAttribute("points", 
 `${ABaseLeft.x},${ABaseLeft.y} ${ATip.x},${ATip.y} ${ABaseRight.x},${ABaseRight.y}`
);
polyB.setAttribute("points",
 `${BBaseLeft.x},${BBaseLeft.y} ${BTip.x},${BTip.y} ${BBaseRight.x},${BBaseRight.y}`
);
});
}

/* =======================
MAIN CONTACT-FORM LOGIC
======================= */
document.addEventListener("DOMContentLoaded", () => {
const form = document.getElementById("contactForm");
if (!form) return;

const linesGroup = form.querySelector(".form-lines");
if (!linesGroup) return;

const submitBtn = form.querySelector('button[type="submit"]');
if (!submitBtn) return;

// The input elements (by ID)
const inputElems = formInputsOrder.map(id => document.getElementById(id));

// “isValid” logic is unchanged from your code
function isValid(index) {
const elem = inputElems[index];
if (!elem) return false;
const value = elem.value.trim();
if (!value) return false;
if (elem.type === "email") return value.includes("@");
return true;
}

// Connect consecutive valid inputs with polygon lines
function updateConnectionsBetweenInputs() {
// Clear old stuff
while (linesGroup.firstChild) {
 linesGroup.removeChild(linesGroup.firstChild);
}
// For each consecutive pair
for (let i = 0; i < formInputsOrder.length - 1; i++) {
 if (validStates[i] && validStates[i+1]) {
   createPolygonConnection(inputElems[i], inputElems[i+1], linesGroup, form);
 }
}
}

// Listen to input => revalidate => redraw
inputElems.forEach((elem, index) => {
if (!elem) return;
elem.addEventListener("input", () => {
 validStates[index] = isValid(index);
 updateConnectionsBetweenInputs();
});
});

// On submit => final check
form.addEventListener("submit", e => {
e.preventDefault();
let allValid = true;
for (let i = 0; i < inputElems.length; i++) {
 validStates[i] = isValid(i);
 if (!validStates[i]) allValid = false;
}
updateConnectionsBetweenInputs();

if (!allValid) {
 alert("Por favor completa todos los campos correctamente antes de enviar.");
 return;
}
alert("Formulario enviado correctamente!");
// form.submit() or custom logic
});

// We'll place these “hover lines” in a separate <g> so we can clear them easily
const hoverGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
linesGroup.appendChild(hoverGroup);

submitBtn.addEventListener("mouseenter", () => {
// If the last input (index=3 => "Mensaje") is valid, connect it to the button
if (validStates[3]) {
 createPolygonConnection(inputElems[3], submitBtn, hoverGroup, form);
}
});

submitBtn.addEventListener("mouseleave", () => {
// Clear any connection we created
while (hoverGroup.firstChild) {
 hoverGroup.removeChild(hoverGroup.firstChild);
}
});
});
function buildDynamicProjects() {
const mainContainer = document.getElementById("projects"); 

let sectionIndex = 0; // to alternate left/right layouts
let firstProjectAppended = false; 
Object.keys(projectsData).forEach(projectKey => {
if (projectKey === "Gonzalo Hernandez") return;

sectionIndex++;
const project = projectsData[projectKey];

// Create the outer <div class="project-section">
const section = document.createElement('div');
section.classList.add('project-section');
if (!firstProjectAppended) {
 section.setAttribute('id', 'projectsStart');
 firstProjectAppended = true;
}
// Create the inner <div class="project-container">
const container = document.createElement('div');
container.classList.add('project-container');
section.appendChild(container);

// Decide layout classes (odd => right, even => left)
const isOdd = (sectionIndex % 2 === 1);
const cardClass = isOdd ? 'left-card' : 'right-card';
const textClass = isOdd ? 'text-d' : 'text-i';

// ----- Build the .card -----
const card = document.createElement('div');
card.classList.add('card', cardClass);
card.dataset.project = projectKey;  // so ProjectSection can identify it

// Image container
const imgContainer = document.createElement('div');
imgContainer.classList.add('img-container');
const cardImg = document.createElement('img');
cardImg.src = project.defaultImage || '';
cardImg.alt = '#';
imgContainer.appendChild(cardImg);
card.appendChild(imgContainer);

// Paragraph (will be updated by ProjectSection logic)
const cardP = document.createElement('p');
card.appendChild(cardP);

container.appendChild(card);

// ----- Build the .project-title (h2 + p) -----
const projectTitle = document.createElement('div');
projectTitle.classList.add('project-title', textClass);

const h2 = document.createElement('h2');
h2.textContent = (project.nombreProyecto || project.defaultName || '').toUpperCase();

const descP = document.createElement('p');
descP.textContent = (project.descripcion || '').toUpperCase();

projectTitle.appendChild(h2);
projectTitle.appendChild(descP);
container.appendChild(projectTitle);

// ----- SVG for connections -----
const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
svg.classList.add('connection');
const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
g.classList.add('connections');
svg.appendChild(g);
container.appendChild(svg);

// ----- Create each tech icon -----
(project.expectedTechnologies || []).forEach((techName, i) => {
 const icon = document.createElement('div');
 icon.classList.add('tech-icon');
 icon.dataset.tech = techName;
     
 if(isOdd){ 
   icon.classList.add(`icon-d-${project.expectedTechnologies.length>4?i+1:i+2}`);
 }else{
   icon.classList.add(`icon-i-${project.expectedTechnologies.length>4?i+1:i+2}`);
 }

 // Icon image
 const iconImg = document.createElement('img');
 const techData = project.techContent[techName];
 iconImg.src = `icons/icon_${techName.toLowerCase()}.png`; // fallback
 iconImg.alt = techName;
 icon.appendChild(iconImg);

 container.appendChild(icon);
});

// Finally, attach the new section to the page
mainContainer.appendChild(section);
});
}

function buildProjectsCarousel() {
const mainContainer = document.getElementById("projects");

// Crea la sección de carrusel
const carouselSection = document.createElement('div');
carouselSection.classList.add('carousel-section');

// Título
const title = document.createElement('h2');
title.textContent = 'PROYECTOS';
title.classList.add('carousel-title');
carouselSection.appendChild(title);

// Contenedor principal del carrusel
const carouselContainer = document.createElement('div');
carouselContainer.classList.add('carousel-container');
carouselSection.setAttribute('id', 'carousel');
carouselSection.appendChild(carouselContainer);

const projectKeys = Object.keys(projectsData).filter(key => key !== 'Gonzalo Hernandez');

// Si hay menos de 6 proyectos, no hacemos scroll infinito y los centramos.
// Si hay 6 o más, duplicamos la lista de proyectos para un efecto de "loop" continuo.
if (projectKeys.length < 6) {
carouselContainer.classList.add('carousel-no-scroll');
// Solo creamos una vez los slides
projectKeys.forEach(key => {
 const project = projectsData[key];
 const slide = createSlideItem(key, project);
 slide.dataset.project = key;
 carouselContainer.appendChild(slide);
});
} else {
// Activamos el scroll infinito
carouselContainer.classList.add('carousel-auto-scroll');

// Duplicamos la lista de proyectos => [1,2,3,4,5] => [1,2,3,4,5,1,2,3,4,5]
const duplicatedKeys = projectKeys.concat(projectKeys);

duplicatedKeys.forEach(key => {
 const project = projectsData[key];
 const slide = createSlideItem(key, project);
 slide.dataset.project = key;
 carouselContainer.appendChild(slide);
});
}

mainContainer.appendChild(carouselSection);

document.querySelectorAll('.carousel-slide').forEach(card => {
card.addEventListener('click', () => {
 const projectKey = card.dataset.project;
 openProjectDetails(projectKey);
});
});
}
const portadaImages = [];

Object.keys(projectsData).forEach(projectKey => {
if (projectKey === "Gonzalo Hernandez") return; // skip
const p = projectsData[projectKey];
// Use portadaImage if available, else fallback to defaultImage
const imageURL = p.portadaImage || p.defaultImage;
if (imageURL) portadaImages.push(imageURL);
});

// 2) Cycle them in .imagePortada
let currentIndex = 0;
const portadaEl = document.querySelector(".imagePortada");
if (portadaEl && portadaImages.length > 0) {
// Immediately set the first image
portadaEl.style.backgroundImage = `url('${portadaImages[0]}')`;

// Every 4 seconds => show next image
setInterval(() => {
 currentIndex = (currentIndex + 1) % portadaImages.length;
 portadaEl.style.backgroundImage = `url('${portadaImages[currentIndex]}')`;
}, 4000);
}
// Seleccionamos todos los <a> de la fila de tags
const tagButtons = document.querySelectorAll('.bt_gallery');

const portadaImages2 = [
'projects/missingtrack/missingtrack_portada.png',
'projects/feel4real/feel4real_portada.png',
'projects/dreamdrive/dreamdrive_portada.png',
'projects/trivia/trivia_portada.png'
];

tagButtons.forEach((btn, index) => {
btn.addEventListener('click', e => {
e.preventDefault();    
portadaEl.style.backgroundImage = `url('${portadaImages2[index]}')`;
tagButtons.forEach((otherBtn) => {


 otherBtn.classList.remove('bg_white_2', 'text-color_purple');
 otherBtn.classList.add('bg_none', 'text-color_white');
});

// Activar SOLO el botón clicado
btn.classList.remove('bg_none', 'text-color_white');
btn.classList.add('bg_white_2', 'text-color_purple');
});
// Quitar "activo" de todos los botones

});

// Función auxiliar para crear cada slide
function createSlideItem(key, project) {
const slide = document.createElement('div');
slide.classList.add('carousel-slide');

const img = document.createElement('img');
img.src = project.defaultImage || 'https://via.placeholder.com/300x200';
img.alt = key;
slide.appendChild(img);

const pName = document.createElement('p');
pName.textContent = key.toUpperCase();
slide.appendChild(pName);
slide.dataset.project = key;

return slide;
}

function enableCarouselHoverEffects() {
function getRelativeRect(element, container) {
// container is the .carousel-hover-container's bounding box
const rect = element.getBoundingClientRect();
const contRect = container.getBoundingClientRect();
return {
left: rect.left - contRect.left,
top: rect.top - contRect.top,
width: rect.width,
height: rect.height
};
}
function normalize(v) {
const len = Math.hypot(v.x, v.y);
return len ? { x: v.x/len, y: v.y/len } : { x: 0, y: 0 };
}
function add(v, w) { return { x: v.x + w.x, y: v.y + w.y }; }
function multiply(v, s) { return { x: v.x*s, y: v.y*s }; }

// Get the border intersection of 'element' in the ephemeral container
// relative to a target point (like the ephemeral icon center).
function getBorderIntersection(element, targetPoint, container) {
const r = getRelativeRect(element, container);
const center = { x: r.left + r.width/2, y: r.top + r.height/2 };
const dx = targetPoint.x - center.x;
const dy = targetPoint.y - center.y;
if(dx === 0 && dy === 0) return center;
const absDx = Math.abs(dx);
const absDy = Math.abs(dy);
const halfWidth = r.width/2;
const halfHeight = r.height/2;
let scale = (absDx/halfWidth > absDy/halfHeight) ? halfWidth/absDx : halfHeight/absDy;
return { x: center.x + dx*scale, y: center.y + dy*scale };
}
function getElementBorderSide(element, point, container) {
const r = getRelativeRect(element, container);
const dLeft = Math.abs(point.x - r.left);
const dRight = Math.abs(point.x - (r.left + r.width));
const dTop = Math.abs(point.y - r.top);
const dBottom = Math.abs(point.y - (r.top + r.height));
const min = Math.min(dLeft, dRight, dTop, dBottom);
if(min === dLeft) return "left";
if(min === dRight) return "right";
if(min === dTop) return "top";
return "bottom";
}

const carouselContainer = document.querySelector('.carousel-container');
if (!carouselContainer) return;

// For each slide in the carousel
document.querySelectorAll('.carousel-slide').forEach(slide => {
const projectKey = slide.dataset.project; // we stored it in createSlideItem

if (!projectKey || !projectsData[projectKey]) return;

slide.addEventListener('mouseenter', () => {
// 1) Create the ephemeral container, etc. 
const hoverContainer = document.createElement('div');
hoverContainer.classList.add('carousel-hover-container');
slide.appendChild(hoverContainer);

const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
svg.classList.add('carousel-hover-lines');
hoverContainer.appendChild(svg);

const proj = projectsData[projectKey];
const firstTechs = (proj.expectedTechnologies || []).slice(0, 3);

// We'll store references to each ephemeral icon + line + polygons
const ephemeralItems = [];
let keepAnimating = true; // to stop on mouseleave

firstTechs.forEach((techName, i) => {
const iconDiv = document.createElement('div');
iconDiv.classList.add('carousel-hover-icon');
// if you have CSS transforms or transitions on iconDiv, that's fine
const techInfo = proj.techContent[techName];
const iconImg = document.createElement('img');
iconImg.src = `icons/icon_${techName.toLowerCase()}.png`;
iconImg.alt = techName;
iconDiv.appendChild(iconImg);
hoverContainer.appendChild(iconDiv);

// Create the line + polygons
const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
line.setAttribute('stroke', 'black');
line.setAttribute('stroke-width', '2');
svg.appendChild(line);

// We'll also create the polygons now, but update their coords each frame
const cardPoly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
cardPoly.setAttribute('fill', 'black');
svg.appendChild(cardPoly);

const techPoly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
techPoly.setAttribute('fill', 'black');
svg.appendChild(techPoly);

ephemeralItems.push({ iconDiv, line, cardPoly, techPoly });
});

// 2) Each frame, recalc the position of the icon & update the line/polygons
function updateEphemeralPositions() {
ephemeralItems.forEach(({ iconDiv, line, cardPoly, techPoly }) => {
 // Same border-to-border logic as your "createConnectionForTech"
 // but referencing the ephemeral container + the hovered slide

 // Slide + ephemeral container bounding boxes
 const slideRect = slide.getBoundingClientRect();
 const contRect = hoverContainer.getBoundingClientRect();

 // Icon center
 const iconRect = iconDiv.getBoundingClientRect();
 const iconCenter = {
   x: iconRect.left + iconRect.width/2 - contRect.left,
   y: iconRect.top + iconRect.height/2 - contRect.top
 };
 // Slide center
 const slideCenter = {
   x: slideRect.left + slideRect.width/2 - contRect.left,
   y: slideRect.top  + slideRect.height/2 - contRect.top
 };

 const cardBasePoint = getBorderIntersection(slide, iconCenter, hoverContainer);
 const dCard = normalize({ x: iconCenter.x - slideCenter.x, y: iconCenter.y - slideCenter.y });
 const cardTip = add(cardBasePoint, multiply(dCard, 8));
 const sideCard = getElementBorderSide(slide, cardBasePoint, hoverContainer);
 const baseDirCard = (sideCard==="left" || sideCard==="right") ? { x: 0, y: 1 } : { x: 1, y: 0 };
 const cardBaseLeft = {
   x: cardBasePoint.x - baseDirCard.x*6,
   y: cardBasePoint.y - baseDirCard.y*6
 };
 const cardBaseRight = {
   x: cardBasePoint.x + baseDirCard.x*6,
   y: cardBasePoint.y + baseDirCard.y*6
 };

 const slideBasePoint = getBorderIntersection(iconDiv, slideCenter, hoverContainer);
 const dTech = normalize({ x: slideCenter.x - iconCenter.x, y: slideCenter.y - iconCenter.y });
 const techTip = add(slideBasePoint, multiply(dTech, 8));
 const sideTech = getElementBorderSide(iconDiv, slideBasePoint, hoverContainer);
 const baseDirTech = (sideTech==="left" || sideTech==="right") ? { x: 0, y: 1 } : { x: 1, y: 0 };
 const techBaseLeft = {
   x: slideBasePoint.x - baseDirTech.x*6,
   y: slideBasePoint.y - baseDirTech.y*6
 };
 const techBaseRight = {
   x: slideBasePoint.x + baseDirTech.x*6,
   y: slideBasePoint.y + baseDirTech.y*6
 };

 // Update line endpoints
 line.setAttribute('x1', cardTip.x);
 line.setAttribute('y1', cardTip.y);
 line.setAttribute('x2', techTip.x);
 line.setAttribute('y2', techTip.y);

 // Update polygons
 cardPoly.setAttribute('points', 
   `${cardBaseLeft.x},${cardBaseLeft.y} 
    ${cardTip.x},${cardTip.y} 
    ${cardBaseRight.x},${cardBaseRight.y}`
 );
 techPoly.setAttribute('points',
   `${techBaseLeft.x},${techBaseLeft.y}
    ${techTip.x},${techTip.y}
    ${techBaseRight.x},${techBaseRight.y}`
 );
});
}

function animateFrame() {
if (!keepAnimating) return;
updateEphemeralPositions();
requestAnimationFrame(animateFrame);
}
keepAnimating = true;
animateFrame();

// On mouseleave => remove ephemeral container & stop animating
slide.addEventListener('mouseleave', () => {
keepAnimating = false;
const hoverContainer = slide.querySelector('.carousel-hover-container');
if (hoverContainer) hoverContainer.remove();
}, { once: true });
});

});
}

//After building the carousel, call this:
buildDynamicProjects();
buildProjectsCarousel();
enableCarouselHoverEffects();
// Re-init to apply drag & drop + connections to newly created sections
document.querySelectorAll('.project-container').forEach(container => {
new ProjectSection(container);
});
// ===============================
// Componente ProjectSection
// ===============================
function ProjectSection(container) {
 this.container = container;
 this.card = container.querySelector('.card');
 // Obtener el nombre del proyecto desde data-project
 this.projectName = this.card.dataset.project;
 // Información del proyecto desde projectsData
 this.projectInfo = projectsData[this.projectName] || {};
 this.connectionSVG = container.querySelector('.connection');
 this.connectionsGroup = container.querySelector('.connections');
 this.techIcons = Array.from(container.querySelectorAll('.tech-icon'));
 this.techData = []; // { element, originalLeft, originalTop }
 this.activeTech = null;
 this.lastConnectedTech = null;
 // Para rastrear las tecnologías conectadas
 this.connectedTechs = new Set();
 const self = this;
 
 // Función para obtener el rectángulo relativo al contenedor
 function relativeRect(element) {
   const rect = element.getBoundingClientRect();
   const contRect = self.container.getBoundingClientRect();
   return {
     left: rect.left - contRect.left,
     top: rect.top - contRect.top,
     width: rect.width,
     height: rect.height
   };
 }
 
 // Obtiene el centro (coordenadas relativas al contenedor)
 function getCenter(element) {
   const r = relativeRect(element);
   return { x: r.left + r.width/2, y: r.top + r.height/2 };
 }
 
 // Obtiene la intersección con el borde del elemento
 function getBorderIntersection(element, targetPoint) {
   const r = relativeRect(element);
   const center = { x: r.left + r.width/2, y: r.top + r.height/2 };
   const dx = targetPoint.x - center.x;
   const dy = targetPoint.y - center.y;
   if(dx === 0 && dy === 0) return center;
   const absDx = Math.abs(dx);
   const absDy = Math.abs(dy);
   const halfWidth = r.width/2;
   const halfHeight = r.height/2;
   let scale = (absDx/halfWidth > absDy/halfHeight) ? halfWidth/absDx : halfHeight/absDy;
   return { x: center.x + dx*scale, y: center.y + dy*scale };
 }
 
 // Determina el lado del borde más cercano
 function getElementBorderSide(element, P) {
   const r = relativeRect(element);
   const dLeft = Math.abs(P.x - r.left);
   const dRight = Math.abs(P.x - (r.left + r.width));
   const dTop = Math.abs(P.y - r.top);
   const dBottom = Math.abs(P.y - (r.top + r.height));
   const min = Math.min(dLeft, dRight, dTop, dBottom);
   if(min === dLeft) return "left";
   if(min === dRight) return "right";
   if(min === dTop) return "top";
   return "bottom";
 }
 
 // Funciones de vectores
 function normalize(v) {
   const len = Math.hypot(v.x, v.y);
   return len ? { x: v.x/len, y: v.y/len } : { x: 0, y: 0 };
 }
 function add(v, w) { return { x: v.x + w.x, y: v.y + w.y }; }
 function multiply(v, s) { return { x: v.x * s, y: v.y * s }; }
 
 // Guarda la posición original de cada tech-icon
 this.initTechData = function() {
   self.techIcons.forEach(function(tech) {
     const r = relativeRect(tech);
     self.techData.push({ 
       element: tech,
       originalLeft: r.left,
       originalTop: r.top
     });
   });
 };
 
 // Actualiza la posición original de un tech-icon
 this.updateOriginalPosition = function(tech) {
   const r = relativeRect(tech);
   self.techData.forEach(item => {
     if(item.element === tech) {
       item.originalLeft = r.left;
       item.originalTop = r.top;
     }
   });
 };
 
 // Crea la conexión SVG para un tech-icon
 this.createConnectionForTech = function(tech) {
   const cardCenter = getCenter(self.card);
   const techCenter = getCenter(tech);
   const dx = techCenter.x - cardCenter.x;
   const dy = techCenter.y - cardCenter.y;
   const distance = Math.hypot(dx, dy);
   if(distance >= UNION_RANGE) return null;
   const opacity = 1 - distance/UNION_RANGE;
   
   // Para la tarjeta
   const cardBasePoint = getBorderIntersection(self.card, techCenter);
   const dCard = normalize({ x: techCenter.x - cardCenter.x, y: techCenter.y - cardCenter.y });
   const cardTip = add(cardBasePoint, multiply(dCard, MARKER_HEIGHT));
   const sideCard = getElementBorderSide(self.card, cardBasePoint);
   const baseDirCard = (sideCard==="left" || sideCard==="right") ? { x: 0, y: 1 } : { x: 1, y: 0 };
   const cardBaseLeft = { 
     x: cardBasePoint.x - baseDirCard.x*(MARKER_BASE/2),
     y: cardBasePoint.y - baseDirCard.y*(MARKER_BASE/2)
   };
   const cardBaseRight = { 
     x: cardBasePoint.x + baseDirCard.x*(MARKER_BASE/2),
     y: cardBasePoint.y + baseDirCard.y*(MARKER_BASE/2)
   };
   
   // Para el tech-icon
   const techBasePoint = getBorderIntersection(tech, cardCenter);
   const dTech = normalize({ x: cardCenter.x - getCenter(tech).x, y: cardCenter.y - getCenter(tech).y });
   const techTip = add(techBasePoint, multiply(dTech, MARKER_HEIGHT));
   const sideTech = getElementBorderSide(tech, techBasePoint);
   const baseDirTech = (sideTech==="left" || sideTech==="right") ? { x: 0, y: 1 } : { x: 1, y: 0 };
   const techBaseLeft = { 
     x: techBasePoint.x - baseDirTech.x*(MARKER_BASE/2),
     y: techBasePoint.y - baseDirTech.y*(MARKER_BASE/2)
   };
   const techBaseRight = { 
     x: techBasePoint.x + baseDirTech.x*(MARKER_BASE/2),
     y: techBasePoint.y + baseDirTech.y*(MARKER_BASE/2)
   };
   
   const connGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
   const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
   line.setAttribute("x1", cardTip.x);
   line.setAttribute("y1", cardTip.y);
   line.setAttribute("x2", techTip.x);
   line.setAttribute("y2", techTip.y);
   line.setAttribute("stroke", "black");
   line.setAttribute("stroke-width", "4");
   line.setAttribute("stroke-opacity", opacity);
   connGroup.appendChild(line);
   
   const cardPoly = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
   cardPoly.setAttribute("points", `${cardBaseLeft.x},${cardBaseLeft.y} ${cardTip.x},${cardTip.y} ${cardBaseRight.x},${cardBaseRight.y}`);
   cardPoly.setAttribute("fill", "black");
   cardPoly.setAttribute("fill-opacity", "1");
   connGroup.appendChild(cardPoly);
   
   const techPoly = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
   techPoly.setAttribute("points", `${techBaseLeft.x},${techBaseLeft.y} ${techTip.x},${techTip.y} ${techBaseRight.x},${techBaseRight.y}`);
   techPoly.setAttribute("fill", "black");
   techPoly.setAttribute("fill-opacity", "1");
   connGroup.appendChild(techPoly);
   
   return connGroup;
 };
 
 // Actualiza el contenido de la tarjeta según la tecnología conectada
 this.updateCardContent = function(tech) {
   if(tech && self.projectInfo.techContent && self.projectInfo.techContent[tech.dataset.tech]) {
     const content = self.projectInfo.techContent[tech.dataset.tech];
     self.card.querySelector('p').textContent = content.text;
     self.card.querySelector('img').src = content.image;
   } else {
     // Restaura el contenido por defecto del proyecto
     self.card.querySelector('p').textContent = self.projectInfo.defaultName || "Proyecto";
     self.card.querySelector('img').src = self.projectInfo.defaultImage || "";
   }
 };
 
 // Actualiza todas las conexiones y el contenido de la tarjeta
this.updateAllConnections = function() {
while (self.connectionsGroup.firstChild) {
self.connectionsGroup.removeChild(self.connectionsGroup.firstChild);
}
self.techIcons.forEach(function(tech) {
const conn = self.createConnectionForTech(tech);
if (conn) {
 self.connectionsGroup.appendChild(conn);
}
});

let techForContent = null;
if (self.activeTech) {
const dist = Math.hypot(
 getCenter(self.activeTech).x - getCenter(self.card).x,
 getCenter(self.activeTech).y - getCenter(self.card).y
);
if (dist < UNION_RANGE) techForContent = self.activeTech;
}
if (!techForContent && self.lastConnectedTech) {
const dist = Math.hypot(
 getCenter(self.lastConnectedTech).x - getCenter(self.card).x,
 getCenter(self.lastConnectedTech).y - getCenter(self.card).y
);
if (dist < UNION_RANGE) techForContent = self.lastConnectedTech;
}
self.updateCardContent(techForContent);

// Check if all technologies are connected
if (self.projectInfo.expectedTechnologies) {
const allConnected = self.projectInfo.expectedTechnologies.every(function(techName) {
 return self.connectedTechs.has(techName);
});

}

// Update the project title & desc
const projectTitleElem = self.container.querySelector('.project-title h2');
const projectDescElem  = self.container.querySelector('.project-title p');
if (projectTitleElem && projectDescElem) {
projectTitleElem.textContent = (self.projectInfo.nombreProyecto || self.projectInfo.defaultName || "").toUpperCase();
projectDescElem.textContent  = (self.projectInfo.descripcion   || "").toUpperCase();
}

// ============== 2) "ABOUT ME" PARAGRAPH ==============
// If this is the "Gonzalo Hernandez" project => update the <p> we added
if (self.projectName === "Gonzalo Hernandez") {
const aboutMeP = document.getElementById("aboutMeParagraph");


if(window.innerWidth < 638){
   // If Mobile
 if (aboutMeP) {
 const connectedCount = self.connectedTechs.size;
 if (connectedCount === 0) {
   // If no technologies are connected
   aboutMeP.innerHTML = "No han conectado ninguna tecnología. Toca los íconos para conocer de mí!";
 } else if (connectedCount == 1) {
   // If 1 technologies are connected
   aboutMeP.innerHTML = `Has conectado ${connectedCount} tecnologias por ahora. <br>
   Soy un profesional orientado a la innovación y la creatividad técnica`;
 } else if (connectedCount == 2) {
   // If 2 technologies are connected
   aboutMeP.innerHTML = `Wow! Has conectado ${connectedCount} tecnologias. Aquí tienes un poco más sobre mí: <br>
   Soy un profesional orientado a la innovación y la creatividad técnica, <br>con una sólida experiencia en el desarrollo de soluciones multidisciplinarias que combinan tecnología, diseño y estrategia.`;
 } else if (connectedCount == 3) {
   // If 3 technologies are connected
   aboutMeP.innerHTML = `Wow! Has conectado ${connectedCount} tecnologias. Aquí tienes un poco más sobre mí: <br>
   Soy un profesional orientado a la innovación y la creatividad técnica, <br>con una sólida experiencia en el desarrollo de soluciones multidisciplinarias que combinan tecnología, diseño y estrategia. Me apasiona explorar nuevas fronteras del conocimiento y materializar ideas en proyectos que generen impacto real.`;
 }  else if (connectedCount == 4) {
   // If 4 technologies are connected
   aboutMeP.innerHTML = `¡Conectaste todas las tecnologías! <br>Te invito a conocer sobre mis proyectos, <br>no olvides de conectar las tecnologías para descrurbir mas sobre ellos.`;
 }
}
}
else{
 if (aboutMeP) {
 const connectedCount = self.connectedTechs.size;
 if (connectedCount === 0) {
   // If no technologies are connected
   aboutMeP.innerHTML = "No han conectado ninguna tecnología. Conectá algunas para conocer de mí!";
 } else if (connectedCount < 5) {
   // If fewer than 5 technologies are connected
   aboutMeP.innerHTML = `Has conectado ${connectedCount} tecnologias por ahora. <br>
   Soy un profesional orientado a la innovación y la creatividad técnica`;
 } else if (connectedCount < 8) {
   // If fewer than 5 technologies are connected
   aboutMeP.innerHTML = `Has conectado ${connectedCount} tecnologias por ahora. <br>Soy un profesional orientado a la innovación y la creatividad técnica, <br>Soy un profesional orientado a la innovación y la creatividad técnica, con una sólida experiencia en el desarrollo de soluciones multidisciplinarias que combinan tecnología, diseño y estrategia.`;
 } else if (connectedCount == 12) {
   // If fewer than 5 technologies are connected
   aboutMeP.innerHTML = `¡Conectaste todas las tecnologías! <br>Te invito a conocer sobre mis proyectos, <br>no olvides de conectar las tecnologías para descrurbir mas sobre ellos.`;
 }
 else {
   // If 5 or more are connected
   aboutMeP.innerHTML = `Wow! Has conectado ${connectedCount} tecnologias. Aquí tienes un poco más sobre mí: <br>
   Soy un profesional orientado a la innovación y la creatividad técnica, <br>con una sólida experiencia en el desarrollo de soluciones multidisciplinarias que combinan tecnología, diseño y estrategia. Me apasiona explorar nuevas fronteras del conocimiento y materializar ideas en proyectos que generen impacto real.`;
 }
}
}
}
};

 
 // Eventos de drag & drop y hover
 this.addEventListeners = function() {
   self.techIcons.forEach(function(tech) {
     tech.addEventListener('mousedown', function(e) {
       self.activeTech = tech;
       tech.style.cursor = 'grabbing';
       const rect = tech.getBoundingClientRect();
       const contRect = self.container.getBoundingClientRect();
       self.offsetX = e.clientX - rect.left;
       self.offsetY = e.clientY - rect.top;
       e.preventDefault();
     });
     tech.addEventListener('mouseenter', function(e) {
       tech.style.cursor = 'pointer';
       self.updateCardContent(tech);
     });
     tech.addEventListener('mouseleave', function(e) {
       self.updateAllConnections();
     });
   });
   
   self.card.addEventListener('mouseenter', function(e) {
     self.container.classList.add('card-hovered');
     const cardCenter = getCenter(self.card);
     self.techData.forEach(function(item) {
       const tech = item.element;
       const origCenter = { x: item.originalLeft + tech.offsetWidth/2, y: item.originalTop + tech.offsetHeight/2 };
       const dx = cardCenter.x - origCenter.x;
       const dy = cardCenter.y - origCenter.y;
       tech.style.transform = `translate(${dx * HOVER_FACTOR}px, ${dy * HOVER_FACTOR}px)`;
     });
     self.updateAllConnections();
   });
   self.card.addEventListener('mouseleave', function(e) {
     self.container.classList.remove('card-hovered');
     self.techIcons.forEach(function(tech) {
       tech.style.transform = "";
       const rect = tech.getBoundingClientRect();
       const contRect = self.container.getBoundingClientRect();
       self.techData.forEach(item => {
         if(item.element === tech) {
           item.originalLeft = rect.left - contRect.left;
           item.originalTop = rect.top - contRect.top;
         }
       });
     });
     self.updateAllConnections();
   });
   
   self.container.addEventListener('mousemove', function(e) {
     if (self.activeTech) {
       const contRect = self.container.getBoundingClientRect();
       const x = e.clientX - contRect.left - self.offsetX;
       const y = e.clientY - contRect.top - self.offsetY;
       self.activeTech.style.left = x + 'px';
       self.activeTech.style.top = y + 'px';
       self.updateOriginalPosition(self.activeTech);
       self.updateAllConnections();
     }
   });
   
   self.container.addEventListener('mouseup', function(e) {
     if (self.activeTech) {
       self.activeTech.style.cursor = 'grab';
       const techCenter = getCenter(self.activeTech);
       const cardCenter = getCenter(self.card);
       const distance = Math.hypot(techCenter.x - cardCenter.x, techCenter.y - cardCenter.y);
       if (distance < UNION_RANGE) {
         self.connectedTechs.add(self.activeTech.dataset.tech);
         self.lastConnectedTech = self.activeTech;
       }
       self.activeTech = null;
     }
     self.updateAllConnections();
   });
   
   window.addEventListener('resize', self.updateAllConnections);
   window.addEventListener('load', self.updateAllConnections);
 };
 
 this.initTechData();
 this.addEventListeners();
 this.updateAllConnections();
}

// Inicializa cada sección de proyecto de forma independiente
document.querySelectorAll('.project-container').forEach(container => {
 new ProjectSection(container);
});

document.querySelectorAll('.card').forEach(card => {
 if(card.dataset.project != "Gonzalo Hernandez"){
   card.addEventListener('click', () => {
   const projectKey = card.dataset.project;
   openProjectDetails(projectKey);
 });
 }

});

// A function to build the entire "detail" layout in the overlay
function openProjectDetails(projectKey) {
const project = projectsData[projectKey];
if (!project) return;

// Grab the overlay
const overlay = document.getElementById('projectDetailsOverlay');
if (!overlay) return;

// Mark overlay open => hide backToTop
overlayOpen = true;
backToTopBtn.classList.remove('show'); // force hide
// Build dynamic HTML for each section:
const {
defaultName,
defaultImage,
portadaImage,
expectedTechnologies,
nombreProyecto,
contexto,
objetivo,
innovacion,
desarrollo1,
desarrolloImagen1,
desarrollo2,
desarrolloImagen2,
resultado,
resultadoImagen
} = project;

const title   = nombreProyecto || defaultName || "PROYECTO";
const bgHero  = portadaImage  || ""; // top hero
const techs   = expectedTechnologies || [];

// Build "technologies used" icons
let techIconsHTML = "";
techs.forEach(t => {
techIconsHTML += `
 <div class="tech-icon-card">
   <img src="icons/icon_${t.toLowerCase()}.png" alt="${t}" />
   <p class="font_outfit" style="position:relative; top:15px; color:black;">${t}</p>
 </div>
`;
});

// The big HTML structure for the detail
overlay.innerHTML = `
<!-- Fullscreen hero with project name at bottom -->
<div class="detail-hero" style="background-image: url('${bgHero}');">
 <div class="detail-hero-title">${title}</div>
</div>

<!-- Technologies used -->
<section class="detail-section">
 <h2>TECNOLOGÍAS USADAS</h2>
 <div class="tech-icons-container">
   ${techIconsHTML}
 </div>
</section>

<!-- Objetivo: 3 cards for contexto, objetivo, innovacion -->
<section class="detail-section">
 <h2>OBJETIVO</h2>
 <div class="obj-cards">
   <div class="obj-card" >
     <h3 class="font_outfit">Contexto</h3>
     <p class="font_outfit">${contexto || ""}</p>
   </div>
   <div class="obj-card">
     <h3 class="font_outfit">Objetivo</h3>
     <p class="font_outfit">${objetivo || ""}</p>
   </div>
   <div class="obj-card">
     <h3 class="font_outfit">Innovación</h3>
     <p class="font_outfit">${innovacion || ""}</p>
   </div>
 </div>
</section>

<!-- Desarrollo 1 -->
<section class="detail-section">
 <h2>DESARROLLO</h2>
 <div class="desarrollo-block">
   <img src="${desarrolloImagen1 || ''}" alt="Desarrollo 1" />
   <p class="font_outfit text-color_white" style="padding:1em;">${desarrollo1 || ""}</p>
 </div>
 <!-- Desarrollo 2 -->
 <div class="desarrollo-block">
   <img src="${desarrolloImagen2 || ''}" alt="Desarrollo 2" />
   <p class="font_outfit text-color_white" style="padding:1em;">${desarrollo2 || ""}</p>
 </div>
</section>

<!-- Resultados -->
<section class="detail-section">
 <h2>RESULTADOS</h2>
 <div class="result-fullscreen" style="background-image: url('${resultadoImagen || ''}');">
 </div>
<p class="font_outfit text-color_white" style="padding:1em 1em; text-align:left; background-color:#1e1e1e; width:100%; padding:1em; border-radius: 0px 0px 10px 10px;">${resultado || ""}</p>    
 
</section>
`;

// Slide overlay into view
overlay.style.transform = 'translateX(0)';
// Build dynamic content...
overlay.classList.add('open');
overlay.scrollTop = 0;
// Prevent main page scroll:
document.body.classList.add('no-scroll');
}

document.getElementById('projectDetailsOverlay').addEventListener('click', () => {
const overlay = document.getElementById('projectDetailsOverlay');
overlay.classList.remove('open');
document.getElementById('projectDetailsOverlay').style.transform = 'translateX(100vw)';
// Re-allow main page scroll:
document.body.classList.remove('no-scroll');
overlayOpen = false;
// Once closed, check if user has scrolled down => show/hide
if (window.scrollY > 200) {
backToTopBtn.classList.add('show');
}
});

const backToTopBtn = document.getElementById('backToTopBtn');
let overlayOpen = false; // We'll track if the overlay is open

// Listen for scroll => Show/hide the button
window.addEventListener('scroll', () => {
// If we are near the top or the overlay is open => hide
if (window.scrollY < 200 || overlayOpen) {
backToTopBtn.classList.remove('show');
} else {
backToTopBtn.classList.add('show');
}
});

// Click => scroll to top (smoothly)
backToTopBtn.addEventListener('click', () => {
window.scrollTo({ top: 0, behavior: 'smooth' });
});

